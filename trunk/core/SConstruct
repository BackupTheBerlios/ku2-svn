#
#	SConstruct file for Kane Utilities 2 (core)
#		J. Anton, Copyright 2006+
#

import os

###
#	Initialisation
###
env = Environment(CPPPATH = ["."])

###
#	System settings
###
sysset = ARGUMENTS.get("system", "auto")

###
#	Platform depended variables and actions
###
if env["PLATFORM"] == "win32" and (sysset == "vc" or sysset == "auto"):
	env.Append(CCFLAGS = ["/W3", "/MD", "/Wp64"], \
		CPPDEFINES = ["_CRT_SECURE_NO_DEPRECATE", "KU_OS_WIN32", "KU_TOOL_VCPP"])
		#LINKFLAGS = ["/SUBSYSTEM:WINDOWS"])
	debug_ccflags = ["/ZI"]
	release_ccflags = ["/O2"]
	release_linkflags = []
elif env["PLATFORM"] == "win32" and sysset == "mingw":
	env.Tool("mingw")
	env.Append(CCFLAGS = ["-Wall", "-Wextra", "-Werror-implicit-function-declaration"],
		CPPDEFINES = ["POSIX", "_GNU_SOURCE", "KU_OS_WIN32"])
	debug_ccflags = ["-g3", "-ggdb3", "-pg", "-dm"]
	release_ccflags = ["-O2"]
	release_linkflags = ["-s"]
elif env["PLATFORM"] == "posix" and sysset == "auto":
	env.Append(CCFLAGS = ["-Wall", "-Wextra", "-Werror-implicit-function-declaration"],
		CPPDEFINES = ["POSIX", "_GNU_SOURCE", "KU_OS_POSIX"])
	debug_ccflags = ["-g3", "-ggdb3", "-pg"]
	release_ccflags = ["-O2"]
	release_linkflags = ["-s"]
else:
	print "Unsupported platform: " + env["PLATFORM"] + " (" + sysset + ")"
	Exit()

###
#	Checking header files
###
conf = Configure(env)
if not conf.CheckCHeader("ctype.h"):
	Exit()
if not conf.CheckCHeader("errno.h"):
	Exit()
if not conf.CheckCHeader("libintl.h"):
	env.Append(CPPDEFINES = ["NO_LIBINTL_H"])
if not conf.CheckCHeader("limits.h"):
	Exit()
if not conf.CheckCHeader("stdarg.h"):
	Exit()
if not conf.CheckCHeader("stdint.h"):
	env.Append(CPPDEFINES = ["NO_STDINT_H"])
	if not conf.CheckCHeader("inttypes.h"):
		env.Append(CPPDEFINES = ["NO_INTTYPES_H"])
if not conf.CheckCHeader("stdio.h"):
	Exit()
if not conf.CheckCHeader("stdlib.h"):
	Exit()
if not conf.CheckCHeader("string.h"):
	Exit()
if not conf.CheckCHeader("sys/timeb.h"):
	Exit()
if not conf.CheckCHeader("time.h"):
	Exit()
env = conf.Finish()

###
#	Getting building mode
#	Possible modes:
#		debug - build with debugging
#		release - build with optimisations and witout debuggin
###
mode = ARGUMENTS.get("mode", "debug")
if mode == "debug":
	env.Append(CCFLAGS = debug_ccflags, CPPDEFINES = ["DEBUG"])
	debug = ARGUMENTS.get("debug", "memory,log")
	if "memory" in debug:
		env.Append(CPPDEFINES = ["DEBUG_MEMORY"])
	if "log" in debug:
		env.Append(CPPDEFINES = ["DEBUG_LOG"])
elif mode == "release":
	env.Append(CCFLAGS = release_ccflags)
	env.Append(LINKFLAGS = release_linkflags)
	debug = ""
else:
	print "Invalid mode ( debug|release )"
	Exit()

###
#	Getting list of add-ons to build with.
#	Possible add-ons:
#		gettext - use libintl support
#		thread_safe - build thread-safe functions
###
def_feat = "thread_safe"
enable = ARGUMENTS.get("enable", "")
disable = ARGUMENTS.get("disable", "")
if ("gettext" in def_feat or "gettext" in enable) and not "gettext" in disable:
	env.Append(CPPDEFINES = ["USE_GETTEXT"])
if ("thread_safe" in def_feat or "thread_safe" in enable) and not "thread_safe" in disable:
	env.Append(CPPDEFINES = ["THREAD_SAFE", "_REENTRANT"])

###
#	Getting the install root and prefix
###
install_root = ARGUMENTS.get("root", "/")
install_prefix = ARGUMENTS.get("prefix", "/usr/")

###
#	Kane Utilities 2 sources and includes
###
sources = Split("""
	ku2/ku2.c
	
	ds/stack/stack.c
	ds/arrseq/arrseq.c
	ds/graph/graph.c
	ds/abtree/abtree.c
	ds/list/dl_list.c
	
	dp/resmanager/res.c
	dp/var/var.c
	dp/var/vspace.c
	dp/var/vlist.c
	
	other/other.c
	io/cfgreader/cfg.c
	io/log/log.c
	""")

includes = Split("""
	ku2/ku2info.h
	ku2/host.h
	ku2/debug.h
	ku2/memory.h
	ku2/gettext.h
	ku2/directives.h
	ku2/ecode.h
	ku2/types.h
	ds/stack/stack.h
	ds/arrseq/arrseq.h
	ds/graph/graph.h
	ds/abtree/abtree.h
	ds/list/list.h
	dp/resmanager/res.h
	dp/var/vlist.h
	dp/var/var.h
	dp/var/vspace.h
	other/other.h
	io/cfgreader/cfg.h
	io/log/log.h
	""")

###
#	Building and Installing
###
ku2lib = env.Library("ku2", sources)

env.Alias("install", install_root+install_prefix)
env.Install(install_root+install_prefix+"/lib/", ku2lib)
env.Install(install_root+install_prefix+"/lib/pkgconfig/", File("ku2.pc"))
for c_inc in includes:
	c_inc_f = File(c_inc)
	env.Install(install_root+install_prefix+"/include/ku2/core/"+os.path.dirname(c_inc_f.path), c_inc_f)

Default(ku2lib)
